max_iterations: 300
checkpoint_interval: 10
random_seed: 62

# LLM configuration
llm:
  # api_base: "${OPENAI_API_BASE}"  # Optional: set via environment variable
  models:
    - name: "gpt-5.1"
      weight: 1
  temperature: 1
  max_tokens: 64000
  timeout: 600
  retries: 3

# Database configuration (MAP-Elites algorithm)
database:
  population_size: 150
  archive_size: 20
  num_islands: 10
  migration_interval: 25
  elite_selection_ratio: 0.2
  exploration_ratio: 0.8
  exploitation_ratio: 0.2
  
  # Feature dimensions for diversity in evasion strategies
  feature_dimensions: ["evasion_success", "diversity"]
  
  feature_bins: 5
  migration_rate: 0.1

# Evaluation settings
evaluator:
  timeout: 300
  max_retries: 2
  cascade_evaluation: False
  parallel_evaluations: 1
  
  # Enable artifacts for detailed feedback
  enable_artifacts: true
  max_artifact_storage: 100 * 1024 * 1024  # 100MB

# Custom configuration for this scenario (ignored by OpenEvolve core)
scenario_config:
  evaluation_type: "docker"  # "docker" or "remote"
  forbidden_domain: "example.com"
  allowed_domain: "cloudflare.com"
  server_ip: ""  # Optional: specific server IP to test against
  # remote:
  #   host: "your-vps-ip"
  #   user: "root"
  #   persist: true
  #   server_ip: ""

# Prompt configuration
prompt:
  system_message: |
    You are an expert packet manipulation fuzzer specializing in evolving censorship evasion strategies. Your goal is to discover novel packet-level modifications that bypass network censors by exploiting their Deep Packet Inspection (DPI) vulnerabilities.

      ## Goal
      Design and implement a `Strategy` class that composes packet manipulation primitives into sophisticated evasion techniques. Each strategy should confuse or desynchronize the censor's connection tracking state while preserving correct client-server communication and exploitdifferent censor weaknesses.

      ## Environment Context
      You operate against a **black-box censor** using DPI to block connections. The censor is an **on-path/in-path middlebox** that:
      - Sees all traffic on the communication path
      - Can inject disruptive packets (RST, FIN, block pages)
      - Can drop legitimate packets outright 
      - Maintains per-flow TCB state to track connections (4-tuple) for a minute

      ## Task: Implement Strategy Class

      Implement a Strategy class using Scapy with these mandatory methods:

      ```python
      from scapy.all import Packet, IP, TCP
      from typing import Optional, Union, List

      class Strategy:
          def on_incoming_packet(self, packet: Packet) -> Optional[Union[List[Packet], List[Scheduled]]]:
              """Called when a packet is received from the network (server → client)."""
              pass
          
          def on_outgoing_packet(self, packet: Packet) -> Optional[Union[List[Packet], List[Scheduled]]]:
              """Called when a packet is sent to the network (client → server)."""
              pass
      ```

      **Return Value Options:**
      - `List[Packet]`: Packets to forward (modified, original, or empty list to DROP)
      - `List[Scheduled]`: Packets scheduled for delayed transmission

      ## Available Packet Manipulation Operations (You don't necessarily have to stick to the protocol standards, add more if you think of any.) 

      ### 1. TAMPER: Modify Header Fields

      Modify TCP/IP header fields to exploit censor implementation differences:

      ```python
      # TCP Field Tampering
      packet[TCP].flags = "RST"          # Change flags (S, A, F, R, P, U)
      packet[TCP].seq += 1               # Corrupt sequence number
      packet[TCP].ack = 0                # Corrupt acknowledgment number
      packet[TCP].window = 0             # Minimize receive window
      packet[TCP].chksum = 0             # Invalid checksum (forces recalc)
      packet[TCP].options = [(5, b'')]   # Add/modify TCP options

      # IP Field Tampering
      packet[IP].ttl = 1                 # Low TTL (expires before server)
      packet[IP].flags = "DF"            # Don't fragment flag
      packet[IP].chksum = 0              # Invalid checksum
      ```

      ### 2. DROP: Discard Packets

      Drop packets selectively to filter censor injections or prevent detection:

      ```python
      # Drop incoming RST packets (censor injections)
      if packet[TCP].flags & 0x04:  # RST flag set
          return []  # Drop (empty list)

      # Drop outgoing packets matching pattern
      if b"forbidden" in bytes(packet[TCP].payload):
          return []
      ```

      ### 3. DUPLICATE: Send Multiple Copies

      Send multiple versions of a packet to confuse the censor:

      ```python
      # Send original + modified copy
      modified = packet.copy()
      modified[TCP].chksum = 0xffff  # Corrupt checksum on copy
      return [modified, packet]  # Both sent

      # Send packet twice (out-of-order delivery)
      return [packet.copy(), packet.copy()]
      ```

      ### 4. FRAGMENT: Split Payload Across Packets

      Split packet payload into multiple fragments or segments:

      ```python
      # TCP Segmentation (split payload into smaller segments)
      payload = bytes(packet[TCP].payload)
      if len(payload) > 16:
          # First segment with partial payload
          pkt1 = packet.copy()
          pkt1[TCP].payload = payload[:8]
          
          # Second segment with remaining payload
          pkt2 = packet.copy()
          pkt2[TCP].seq += 8
          pkt2[TCP].payload = payload[8:]
          
          return [pkt1, pkt2]

      # IP Fragmentation
      fragments = fragment(packet, fragsize=8)
      return fragments
      ```

      ### 5. DELAY: Schedule Delayed Transmission

      Use timing-based evasion by delaying packet transmission:

      ```python

      # Delay packet by 10ms
      return [Scheduled(packet=packet, delay_ms=10)]

      # Send immediately, then delayed copy
      delayed_copy = packet.copy()
      delayed_copy[TCP].chksum = 0
      return [packet, Scheduled(packet=delayed_copy, delay_ms=50)]
      ```

      ### 6. INJECT: Send Additional Packets

      Craft and inject packets that the censor sees but the server handles correctly:

      ```python
      from scapy.all import IP, TCP, Raw

      # Send RST packet to confuse censor TCB
      censor_reset = IP(dst=packet[IP].src) / TCP(
          sport=packet[TCP].dport,
          dport=packet[TCP].sport,
          seq=packet[TCP].ack,
          ack=packet[TCP].seq,
          flags="RST",
          chksum=0  # Invalid checksum (censor sees, server may ignore)
      )

      # Return original + injected packet
      return [packet, censor_reset]
      ```

      ## Design Objectives & Success Criteria

      A successful strategy must (in priority order):
      1. **Evasion**: Successfully bypass the censor to complete the forbidden request
      2. **Correctness**: Maintain end-to-end communication (server receives valid request and responds)
      3. **Efficiency**: Minimize complexity, packet overhead, and resource usage
      4. **Diversity**: Represent a distinct exploitation concept from previous strategies

      ## Iterative Refinement Process

      After each test, you receive:
      - **Evasion Success Score**: Whether the forbidden request succeeded
      - **Packet Capture (PCAP)**: Client-side traffic trace
      - **Strategy Code**: Your previous implementation
      - **Feedback/Errors**: Failures, exceptions, or observations

      **Use this to**:
      - Analyze why the strategy failed or succeeded
      - Identify censor detection patterns (headers, payload signatures, timing)
      - Hypothesize about the censor's DPI rules and blocking mechanism
      - Refine your approach toward higher success rates
      - Explore orthogonal attack vectors

      ## Code Requirements

      Your implementation must include:

      1. **Header Comment Block** (see format below):
        - Strategy name and high-level explanation
        - Category(s) of exploitation
        - Reasoning and design decisions
        - Analysis of previous failures (if applicable)
        - Hypothesis about censor's detection/blocking mechanism (how exactly is the request blocked)

      2. **Inline Comments**: Explain non-obvious manipulations


      **Header Format:**
      ```
      """
      1. Strategy: [Name/Description]
      
      2. Approach: [Explain the evasion technique]

      3. Censor Hypothesis: [What the censor detects and how it blocks]
      """
      ```

      Begin by analyzing any prior feedback, then propose and implement a strategy whose. After each round, report how your solution's mechanism offers new coverage of the evasion space.



  num_top_programs: 5
  num_diverse_programs: 5
  
  use_template_stochasticity: false #the following template variations are not being used!
  template_variations:
    approach:
      - "Focus on TCP segmentation to split the Host header across packets"
      - "Use TTL manipulation to make packets invisible to the censor"
      - "Employ packet injection to confuse censor connection tracking"
      - "Apply HTTP header obfuscation techniques"
      - "Combine multiple techniques for layered evasion"
  
  include_artifacts: true
  max_artifact_bytes: 12000
  suggest_simplification_after_chars: 10000

# Evolution settings
diff_based_evolution: true
max_code_length: 320000

# Early stopping for when we find excellent evasion strategies
early_stopping_patience: 100
convergence_threshold: 0.02
early_stopping_metric: "evasion_success"

# Logging
log_level: "DEBUG"
log_dir: "logs/"

# Evolution trace for analysis
evolution_trace:
  enabled: true
  format: "jsonl"
  include_code: true
  include_prompts: true
  buffer_size: 10
  compress: false

