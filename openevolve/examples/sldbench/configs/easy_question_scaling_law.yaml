# Configuration for easy question scaling law discovery with OpenEvolve
max_iterations: 50
checkpoint_interval: 1
log_level: "INFO"
random_seed: 42

# LLM configuration
llm:
  api_base: ""
  max_tokens: 16384
  timeout: 240
  retries: 10
  retry_delay: 10

# Prompt configuration
prompt:
  system_message: |
    You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between compute (FLOPs) and LLM performance on easy questions, which exhibits a characteristic U-shaped or double descent pattern.

    **IMPORTANT: The scaling law function must use no more than 6 parameters to capture the U-shaped scaling pattern.**

    Focus on mathematical accuracy across different benchmark tasks, cross-task generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability. The U-shaped pattern is critical: performance initially worsens with scale before improving again.

    **DATA CHARACTERISTICS:**
    - Features: [log_flops] - 1D input in log10 scale
    - Labels: brier_score - scalar output (negative values, more negative = better)
    - Dataset size: 516 total (389 train + 127 test)
    - Log FLOPs range: [-0.9, 2.9] approximately (log10 of FLOPs in 1E21 units)

    The function signatures must remain:

    ```python
    def scaling_law_func(data_points, params):
        # data_points: (N,1) array with columns [log_flops]
        # log_flops: Array of log10(FLOPs in 1E21 units)
        # params: Array of up to 6 parameters to capture U-shaped pattern
        # Returns: Predicted brier_score values (negative)

    def fit_scaling_law(data_points, loss_values):
        # data_points: (N,1) array with columns [log_flops]
        # log_flops: Array of log10(FLOPs in 1E21 units)
        # loss_values: Array of corresponding brier_score values
        # Returns: Optimized parameters (up to 6 parameters)
    ```

    Write all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.

    You are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.

  num_top_programs: 3
  num_diverse_programs: 2
  use_template_stochasticity: true

# Database configuration for evolution
database:
  population_size: 100
  archive_size: 50
  num_islands: 5
  migration_interval: 25
  migration_rate: 0.1
  elite_selection_ratio: 0.1
  exploration_ratio: 0.2
  exploitation_ratio: 0.7
  feature_dimensions: ["combined_score", "complexity", "diversity"]
  feature_bins: 10

# Evaluator configuration
evaluator:
  timeout: 600
  max_retries: 3
  cascade_evaluation: false
  cascade_thresholds: [0.3, 0.6]
  parallel_evaluations: 4
  use_llm_feedback: false

# Evolution settings
diff_based_evolution: false
max_code_length: 100000
